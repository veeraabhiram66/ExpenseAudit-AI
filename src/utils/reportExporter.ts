// Professional Report Exporter
// Generates comprehensive audit reports in multiple formats

import type { BenfordResult, ProcessedDataset } from '../types';
import type { AnalysisSummary } from './aiSummary';
import type { GeminiSummary } from './geminiIntegration';

export interface ExportOptions {
  format: 'json' | 'pdf' | 'csv' | 'executive';
  includeRawData?: boolean;
  includeCharts?: boolean;
  executiveSummaryOnly?: boolean;
}

/**
 * Generate a professional executive summary report
 */
export function generateExecutiveReport(
  result: BenfordResult,
  dataset: ProcessedDataset,
  aiSummary: AnalysisSummary,
  geminiSummary?: GeminiSummary | null
): string {
  const reportDate = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  return `
# FRAUD DETECTION ANALYSIS REPORT
**Generated by ExpenseAudit AI**
**Date:** ${reportDate}
**Analysis Period:** ${dataset.preview.totalRows.toLocaleString()} transactions analyzed

---

## EXECUTIVE SUMMARY

${aiSummary.executiveSummary}

**Risk Assessment:** ${aiSummary.riskAssessment.level.toUpperCase()} RISK
**Confidence Level:** ${aiSummary.riskAssessment.confidence}%

---

## KEY FINDINGS

${aiSummary.overallFindings.map(finding => `• ${finding}`).join('\n')}

---

## VENDOR ANALYSIS

${aiSummary.vendorInsights.length > 0 ? aiSummary.vendorInsights.map(insight => `• ${insight}`).join('\n') : '• No significant vendor anomalies detected.'}

---

## TRANSACTION PATTERNS

${aiSummary.transactionInsights.length > 0 ? aiSummary.transactionInsights.map(insight => `• ${insight}`).join('\n') : '• No unusual transaction patterns identified.'}

---

## TEMPORAL ANALYSIS

${aiSummary.timeBasedInsights.length > 0 ? aiSummary.timeBasedInsights.map(insight => `• ${insight}`).join('\n') : '• No time-based anomalies detected.'}

---

## RECOMMENDATIONS

${aiSummary.recommendations.map(rec => `• ${rec}`).join('\n')}

---

## TECHNICAL METRICS

**Statistical Analysis:**
• Mean Absolute Deviation (MAD): ${result.mad.toFixed(4)}
• Chi-Square Statistic: ${result.chiSquare.toFixed(2)}
• Overall Assessment: ${result.overallAssessment.replace('_', ' ').toUpperCase()}

**Data Quality:**
• Total Transactions: ${aiSummary.keyMetrics.totalTransactions}
• Compliance Score: ${aiSummary.keyMetrics.complianceScore}
• Flagged Vendors: ${aiSummary.keyMetrics.flaggedVendors}
• Suspicious Transactions: ${aiSummary.keyMetrics.suspiciousTransactions}

${geminiSummary ? `
---

## AI-ENHANCED INSIGHTS

${geminiSummary.executiveSummary}

**AI Risk Assessment:** ${geminiSummary.riskAssessment}

**AI Key Findings:**
${geminiSummary.keyFindings.map((finding: string) => `• ${finding}`).join('\n')}

**AI Recommendations:**
${geminiSummary.recommendedActions.map((rec: string) => `• ${rec}`).join('\n')}

**Further Investigation Areas:**
${geminiSummary.furtherInvestigation.map((item: string) => `• ${item}`).join('\n')}

*Generated by ${geminiSummary.model} (${geminiSummary.provider}) on ${new Date(geminiSummary.generatedAt).toLocaleDateString()}*
` : ''}

---

**Report Generated:** ${new Date().toISOString()}
**Analysis Engine:** ExpenseAudit AI v1.0 | Benford's Law Implementation
**Audit Trail:** This report is based on statistical analysis of first-digit frequency distribution
`;
}

/**
 * Export flagged transactions to CSV format
 */
export function exportFlaggedTransactionsCSV(result: BenfordResult, dataset: ProcessedDataset): string {
  const headers = ['Index', 'Amount', 'Vendor', 'First Digit', 'Risk Level', 'Reason', 'Date'];
  const csvContent = [headers.join(',')];

  result.flaggedTransactions.forEach(transaction => {
    const originalRow = dataset.data[transaction.index];
    const row = [
      transaction.index.toString(),
      `"$${transaction.amount.toLocaleString()}"`,
      `"${transaction.vendor || 'N/A'}"`,
      transaction.firstDigit.toString(),
      transaction.riskLevel,
      `"${transaction.reason}"`,
      originalRow?.date ? originalRow.date.toLocaleDateString() : 'N/A'
    ];
    csvContent.push(row.join(','));
  });

  return csvContent.join('\n');
}

/**
 * Export suspicious vendors to CSV format
 */
export function exportSuspiciousVendorsCSV(result: BenfordResult): string {
  const headers = ['Vendor', 'Transaction Count', 'MAD Score', 'Chi-Square', 'Risk Level', 'Suspicious Patterns'];
  const csvContent = [headers.join(',')];

  result.suspiciousVendors.forEach(vendor => {
    const row = [
      `"${vendor.vendor}"`,
      vendor.transactionCount.toString(),
      vendor.mad.toFixed(4),
      vendor.chiSquare.toFixed(2),
      vendor.riskLevel,
      `"${vendor.suspiciousPatterns.join('; ')}"`
    ];
    csvContent.push(row.join(','));
  });

  return csvContent.join('\n');
}

/**
 * Generate comprehensive JSON export
 */
export function generateJSONExport(
  result: BenfordResult,
  dataset: ProcessedDataset,
  aiSummary: AnalysisSummary,
  geminiSummary?: GeminiSummary | null,
  options: ExportOptions = { format: 'json' }
): Record<string, unknown> {
  return {
    meta: {
      exportType: 'ExpenseAudit_AI_Analysis',
      version: '1.0',
      generatedAt: new Date().toISOString(),
      options
    },
    analysis: {
      summary: aiSummary,
      aiEnhanced: geminiSummary,
      rawResults: result,
      datasetInfo: {
        totalRecords: dataset.preview.totalRows,
        validRecords: dataset.validation.validRows,
        columnMapping: dataset.columnMapping,
        validationSummary: dataset.validation
      }
    },
    export: {
      executiveReport: generateExecutiveReport(result, dataset, aiSummary, geminiSummary),
      flaggedTransactionsCSV: exportFlaggedTransactionsCSV(result, dataset),
      suspiciousVendorsCSV: exportSuspiciousVendorsCSV(result)
    }
  };
}

/**
 * Download file with specified content and format
 */
export function downloadFile(content: string, filename: string, mimeType: string = 'text/plain') {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Generate timestamped filename
 */
export function generateFilename(prefix: string, extension: string): string {
  const timestamp = new Date().toISOString().split('T')[0];
  return `${prefix}_${timestamp}.${extension}`;
}
